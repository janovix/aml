---
alwaysApply: true
---
These examples should be used as guidance when configuring Sentry functionality within a project.

# Environment Configuration

Sentry uses environment variables for multi-environment support (dev/production branches):

| Variable | Description | Values |
|----------|-------------|--------|
| `NEXT_PUBLIC_SENTRY_DSN` | Your Sentry DSN from project settings | `https://xxx@o123.ingest.sentry.io/456` |
| `NEXT_PUBLIC_ENVIRONMENT` | Environment tag for Sentry events | `development` or `production` |

## Sample Rates by Environment

| Environment | Traces | Session Replays | Error Replays |
|-------------|--------|-----------------|---------------|
| `development` | 100% | 100% | 100% |
| `production` | 20% | 10% | 100% |

# Exception Catching
Use `Sentry.captureException(error)` to capture an exception and log the error in Sentry.
Use this in try catch blocks or areas where exceptions are expected

# Tracing Examples
Spans should be created for meaningful actions within applications like button clicks, API calls, and function calls
Use the `Sentry.startSpan` function to create a span
Child spans can exist within a parent span

## Custom Span instrumentation in component actions
The `name` and `op` properties should be meaningful for the activities in the call.
Attach attributes based on relevant information and metrics from the request
```javascript
function TestComponent() {
  const handleTestButtonClick = () => {
    // Create a transaction/span to measure performance
    Sentry.startSpan(
      {
        op: "ui.click",
        name: "Test Button Click",
      },
      (span) => {
        const value = "some config";
        const metric = "some metric";
        // Metrics can be added to the span
        span.setAttribute("config", value);
        span.setAttribute("metric", metric);
        doSomething();
      },
    );
  };
  return (
    <button type="button" onClick={handleTestButtonClick}>
      Test Sentry
    </button>
  );
}
```

## Custom span instrumentation in API calls
The `name` and `op` properties should be meaningful for the activities in the call.
Attach attributes based on relevant information and metrics from the request
```javascript
async function fetchUserData(userId) {
  return Sentry.startSpan(
    {
      op: "http.client",
      name: `GET /api/users/${userId}`,
    },
    async () => {
      const response = await fetch(`/api/users/${userId}`);
      const data = await response.json();
      return data;
    },
  );
}
```

# Logs
Where logs are used, ensure Sentry is imported using `import * as Sentry from "@sentry/nextjs"`
Enable logging in Sentry using `Sentry.init({ enableLogs: true })`
Reference the logger using `Sentry.logger`
Sentry offers a consoleLoggingIntegration that can be used to log specific console error types automatically without instrumenting the individual logger calls

## Configuration
In NextJS the client side Sentry initialization is in `instrumentation-client.ts`, the server initialization is in `sentry.server.config.ts` and the edge initialization is in `sentry.edge.config.ts`
Initialization does not need to be repeated in other files, it only needs to happen the files mentioned above. You should use `import * as Sentry from "@sentry/nextjs"` to reference Sentry functionality

### Baseline with Environment Detection
```javascript
import * as Sentry from "@sentry/nextjs";

// Environment variables (set in Cloudflare Worker config or .env)
const dsn = process.env.NEXT_PUBLIC_SENTRY_DSN;
const environment =
  process.env.NEXT_PUBLIC_ENVIRONMENT || process.env.NODE_ENV || "development";
const isDevelopment = environment === "development";

Sentry.init({
  dsn,
  environment,
  tracesSampleRate: isDevelopment ? 1.0 : 0.2,
  enableLogs: true,
  sendDefaultPii: true,
});
```

### Client-side with Replay Integration
```javascript
import * as Sentry from "@sentry/nextjs";

const dsn = process.env.NEXT_PUBLIC_SENTRY_DSN;
const environment =
  process.env.NEXT_PUBLIC_ENVIRONMENT || process.env.NODE_ENV || "development";
const isDevelopment = environment === "development";

Sentry.init({
  dsn,
  environment,
  integrations: [Sentry.replayIntegration()],
  tracesSampleRate: isDevelopment ? 1.0 : 0.2,
  enableLogs: true,
  replaysSessionSampleRate: isDevelopment ? 1.0 : 0.1,
  replaysOnErrorSampleRate: 1.0,
  sendDefaultPii: true,
});

export const onRouterTransitionStart = Sentry.captureRouterTransitionStart;
```

### Logger Integration
```javascript
Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  integrations: [
    // send console.log, console.error, and console.warn calls as logs to Sentry
    Sentry.consoleLoggingIntegration({ levels: ["log", "error", "warn"] }),
  ],
});
```

## Logger Examples
`logger.fmt` is a template literal function that should be used to bring variables into the structured logs.
```javascript
logger.trace("Starting database connection", { database: "users" });
logger.debug(logger.fmt`Cache miss for user: ${userId}`);
logger.info("Updated profile", { profileId: 345 });
logger.warn("Rate limit reached for endpoint", {
  endpoint: "/api/results/",
  isEnterprise: false,
});
logger.error("Failed to process payment", {
  orderId: "order_123",
  amount: 99.99,
});
logger.fatal("Database connection pool exhausted", {
  database: "users",
  activeConnections: 100,
});
```
